import tensorflow as tf
#print tf.__version__
#import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime
from graphnnSiamese import graphnn
from utils import *
import os
import argparse
import json
import csv

parser = argparse.ArgumentParser()
parser.add_argument('--device', type=str, default='0',
        help='visible gpu device')
parser.add_argument('--fea_dim', type=int, default=7,
        help='feature dimension')
parser.add_argument('--embed_dim', type=int, default=64,
        help='embedding dimension')
parser.add_argument('--embed_depth', type=int, default=2,
        help='embedding network depth')
parser.add_argument('--output_dim', type=int, default=64,
        help='output layer dimension')
parser.add_argument('--iter_level', type=int, default=5,
        help='iteration times')
parser.add_argument('--lr', type=float, default=1e-4,
        help='learning rate')
parser.add_argument('--epoch', type=int, default=100,
        help='epoch number')
parser.add_argument('--batch_size', type=int, default=5,
        help='batch size')
parser.add_argument('--load_path', type=str,
        default='./saved_model/graphnn-model_best',
        help='path for model loading, "#LATEST#" for the latest checkpoint')
parser.add_argument('--log_path', type=str, default=None,
        help='path for training log')
parser.add_argument('-i', '--inputFile', type=str, default=None, help='binary ACFG file')
parser.add_argument('--vul', type=str, default=None, help='vulnerability ACFG file')

def load_graph(F_NAME):
    graphs = []
    label = None
    with open(F_NAME) as inf:
        for line in inf:
            g_info = json.loads(line.strip())
            cur_graph = graph(g_info['n_num'], label, g_info['fname'])
            for u in range(g_info['n_num']):
                cur_graph.features[u] = np.array(g_info['features'][u])
                for v in g_info['succs'][u]:
                    cur_graph.add_edge(u, v)
            graphs.append(cur_graph)

    return graphs

def generate_input(Graphs1, Graphs2, FEATURE_DIM):
    input1 = []
    input2 = []
    maxN1 = 0
    maxN2 = 0
    for i in range(len(Graphs1)):
        maxN1 = max(maxN1, Graphs1[i].node_num)
    for i in range(len(Graphs2)):
        maxN2 = max(maxN2, Graphs2[i].node_num)

    X1_input = np.zeros((1, maxN1, FEATURE_DIM))
    X2_input = np.zeros((1, maxN2, FEATURE_DIM))
    node1_mask = np.zeros((1, maxN1, maxN1))
    node2_mask = np.zeros((1, maxN2, maxN2))

    for i in range(len(Graphs1)):
        g = Graphs1[i]
        for u in range(g.node_num):
            X1_input[0, u, :] = np.array(g.features[u])
            for v in g.succs[u]:
                node1_mask[0, u, v] = 1
        input1.append((X1_input, node1_mask))
        X1_input = np.zeros((1, maxN1, FEATURE_DIM))
        node1_mask = np.zeros((1, maxN1, maxN1))

    for i in range(len(Graphs2)):
        g = Graphs2[i]
        for u in range(g.node_num):
            X2_input[0, u, :] = np.array(g.features[u])
            for v in g.succs[u]:
                node2_mask[0, u, v] = 1
        input2.append((X2_input, node2_mask))
        X2_input = np.zeros((1, maxN2, FEATURE_DIM))
        node2_mask = np.zeros((1, maxN2, maxN2))

    return input1, input2

if __name__ == '__main__':
    args = parser.parse_args()
    args.dtype = tf.float32
    print("=================================")
    print(args)
    print("=================================")

    os.environ["CUDA_VISIBLE_DEVICES"] = args.device
    Dtype = args.dtype
    NODE_FEATURE_DIM = args.fea_dim
    EMBED_DIM = args.embed_dim
    EMBED_DEPTH = args.embed_depth
    OUTPUT_DIM = args.output_dim
    ITERATION_LEVEL = args.iter_level
    LEARNING_RATE = args.lr
    MAX_EPOCH = args.epoch
    BATCH_SIZE = args.batch_size
    LOAD_PATH = args.load_path
    LOG_PATH = args.log_path

    #DATA_FILE_NAME = './data/acfgSSL_7/openssl-1.0.1f-armeb-linux-O0v54.json'
    #Vul_FILE_NAME = './data/openssl_inline.json'
    DATA_FILE_NAME = args.inputFile
    Vul_FILE_NAME = args.vul

    Graphs1 = load_graph(DATA_FILE_NAME)
    Graphs2 = load_graph(Vul_FILE_NAME)
    input1, input2 = generate_input(Graphs1, Graphs2, NODE_FEATURE_DIM)

    # Model
    gnn = graphnn(
        N_x=NODE_FEATURE_DIM,
        Dtype=Dtype,
        N_embed=EMBED_DIM,
        depth_embed=EMBED_DEPTH,
        N_o=OUTPUT_DIM,
        ITER_LEVEL=ITERATION_LEVEL,
        lr=LEARNING_RATE
    )
    gnn.init(LOAD_PATH, LOG_PATH)

    i = 0
    j = 0
    with open("./result/search_result.csv", "w") as csvfile:
        writer = csv.writer(csvfile)
        for cur_data1 in input2:
            X1, m1 = cur_data1
            #print X1, m1
            for cur_data2 in input1:
                X2, m2 = cur_data2
                #print X2, m2
                diff = gnn.calc_diff(X1, X2, m1, m2)
                print Graphs1[j].name, diff, Graphs2[i].name
                if (diff > 0.5):
                    writer.writerow([Graphs1[j].name, diff, Graphs2[i].name])
                j += 1
            i += 1
            j = 0




